<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html xmlns:background-color="http://www.w3.org/1999/xhtml" xmlns:max-width="http://www.w3.org/1999/xhtml">
<head>
    <title>VT AR Tour Documentation</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <!--[if lte IE 8]>
    <script src="../../assets/js/ie/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" href="../../assets/css/main.css"/>
    <link rel="stylesheet" href="../../assets/css/custom.css"/>
    <link rel="stylesheet" href="documentation.css"/>

    <!--Code Syntax Highlighting JS library-->
    <link rel="stylesheet" href="../../assets/css/xcode.css"/>
    <script src="../../assets/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>

<!-- Wrapper -->
<div id="wrapper">

    <!-- Main -->
    <div id="main">
        <div class="inner">

            <!-- Header -->
            <header id="header">
                <a href="" class="logo">Documentation</a>
            </header>

            <!-- Content -->
            <section>
                <h2>Overview</h2>
                <p>The hierarchical documentation documents how to build many of the functionalities found in the AR
                    Tour.</p>

                <h2>Contents</h2>
                <ul class="no-before">
                    <li><h3><a href="#getting-started">Getting Started</a></h3></li>
                    <li>
                        <ul class="no-before">
                            <li><a href="#creating-project">Creating the Project</a></li>
                            <li><a href="#configuring-environment">Configuring Your Environment</a></li>
                            <li><a href="#create-ar-session">Creating an AR Session</a></li>
                        </ul>
                    </li>
                    <li><h3><a href="#contextual-hints">Contextual Hints</a></h3></li>
                    <li>
                        <ul class="no-before">
                            <li><a href="#creating-overlay-hint">Creating an Overlay Hint</a></li>
                            <li><a href="#making-overlay">Making the Overlay</a></li>
                            <li><a href="#displaying-overlay">Displaying the Overlay</a></li>
                        </ul>
                    </li>
                    <li><h3><a href="#location-based-ar">Location-Based AR</a></h3></li>
                    <li>
                        <ul class="no-before">
                            <li><a href="#getting-user-location">Getting the User's Location</a></li>
                            <li><a href="#setting-up-coord-sys">Setting up Your Coordinate System</a></li>
                            <li><a href="#handling-location-updates">Handling Location Updates</a></li>
                        </ul>
                    </li>
                    <li><h3><a href="#processing-buildings">Processing Buildings</a></h3></li>
                    <li>
                        <ul class="no-before">
                            <li><a href="#computing-distance">Computing the Distance Between Coordinates</a></li>
                            <li><a href="#creating-label-nodes">Creating Building Label Nodes</a></li>
                            <li><a href="#creating-building-detail-nodes">Creating Building Detail Nodes</a></li>
                            <li><a href="#adding-nodes-to-scene">Adding Nodes to the Scene</a></li>
                        </ul>
                    </li>
                    <li><h3><a href="#async-data-download">Asynchronous Data Downloading</a></h3></li>
                    <li>
                        <ul class="no-before">
                            <li><a href="#showing-loading-indicator">Showing the Loading Indicator</a></li>
                            <li><a href="#download-and-display-data">Downloading and Displaying Data</a></li>
                        </ul>
                    </li>
                    <li><h3><a href="#leaving-ar">Leaving an AR View</a></h3></li>
                    <li>
                        <ul class="no-before">
                            <li><a href="#back-button">Option 1: Back Button</a></li>
                            <li><a href="#ui-navigation-controller">Option 2: UINavigationController</a></li>
                        </ul>
                    </li>
                </ul>
            </section>

            <section>
                <h2 id="getting-started">Getting Started - Project Creation and Environment Configuration</h2>
                <h3 id="creating-project">Creating the project</h3>
                <p>ARKit projects requires Xcode 9.0 and above.</p>
                <ol>
                    <li>Launch Xcode and select <b>Create a new Xcode project</b> from the Xcode welcome screen, or
                        select
                        <b>File
                            → New → Project...</b></li>
                    <li>Choose <b> iOS → Application → Augmented Reality App</b> and click next.<br><img
                            src="../common-images/application-type-selection.png" width="70%"/></li>
                    <li>In the <i>Choose options for your new project</i> dialog, choose <b>SceneKit</b> as the <i>Content
                        Technology</i><img
                            src="../common-images/scenekit.png" width="70%"/></li>
                </ol>

                <h3 id="configuring-environment">Configuring Your Environment</h3>
                <p>Creating a new ARKit project generates a sample application, so some cleanup is required.</p>
                <ol>
                    <li>In ViewController.swift, delete the sample code from <code>viewDidLoad()</code>.<br><img
                            src="../common-images/viewDidLoad.png" width="70%"/></li>
                    <li>Delete everything inside the art.scnassets folder. <br><img src="../common-images/art.png"
                                                                                    width="70%"/></li>
                </ol>

                <h3 id="create-ar-session">Creating an AR Session</h3>
                <p><a href="https://developer.apple.com/documentation/arkit/arsession" target="_blank">ARSession</a> is
                    an
                    object shared by views that require motion tracking and image processing. Your application will use
                    an <a
                            href="https://developer.apple.com/documentation/arkit/arscnview">ARSCNView</a> to display 3D
                    SceneKit objects in the camera view.</p>
                <p>ARSession must be configured before it can be run by ARSCNView. To do this, create an instance of <a
                        href="https://developer.apple.com/documentation/arkit/arworldtrackingconfiguration"
                        target="_blank">ARWorldTrackingConfiguration</a>
                    and configure it to detect horizontal planes. Then the SceneView can run the ARSession.</p>
                <p>This configuration can be achieved by adding the following code to the <code>viewWillAppear()</code>
                    method of your ViewController class.</p>

                <pre><code>
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)

    // Create a session configuration
    let configuration = ARWorldTrackingConfiguration()

    // Detect horizontal planes in the scene
    configuration.planeDetection = .horizontal

    // Run the view's session
    sceneView.session.run(configuration)
}
            </code></pre>

                <a href="#">Back to top</a>
            </section>

            <section>
                <h2 id="contextual-hints">Contextual Hints</h2>
                <div class="row">
                    <div class="column">
                        <p>Displaying help messages and hints in AR/VR is difficult to do without disrupting the user's
                            experience. One approach is to show context-sensitive hints in an overlay. This approach has
                            two advantages: the user is unlikely to miss these hints, and they don't disrupt the current
                            application flow. One disadvantage to this approach is that is can be difficult to determine
                            when to display these types of hints.</p>
                    </div>
                    <div class="column" align="center">
                        <img src="images/hint.gif" width="50%"/>
                    </div>
                </div>

                <h3 id="creating-overlay-hint">Creating an Overlay Hint</h3>
                <p>Recall that an ARSCNView contains a SceneKit scene. All SceneKit scenes contain a <code>overlaySKScene</code>,
                    perfect for overlaying 2D SpriteKit content. It's commonly used in game development to implement
                    heads-up displays, but can just as easily be used to create overlay labels.</p>
                <p>Create your <code>overlaySKScene</code> in your <code>viewDidLoad()</code> method. You'll want to
                    fade this overlay in and out. Creation and animation are discussed below.</p>
                <pre><code>
    override func viewDidLoad() {
        ...
        sceneView.overlaySKScene = createOverlayHintLabel(withText: "Your hint text here")
        fadeNodeInAndOut(node: sceneView.overlaySKScene!, initialDelay: 2.0, fadeInDuration: 1.0, displayDuration: 6.0, fadeOutDuration: 1.0)
        ...
    }
                </code></pre>

                <h3 id="making-overlay">Making the Overlay</h3>
                <p>This function returns an SKScene which contains a SKLabelNode that wraps the string
                    <code>withText</code>, similar to the one shown above.</p>
                <pre><code>

    // Creates an overlay containing a label with hint text and a translucent background
    func createOverlayHintLabel(withText: String) -> SKScene {
        // Create an overlay banner to be positioned in the middle of the SceneView.
        let overlayScene = SKScene(size: sceneView.bounds.size)
        overlayScene.scaleMode = .resizeFill

        // Configure the hint label
        let hintLabel = SKLabelNode(text: withText)
        hintLabel.fontSize = 40
        hintLabel.verticalAlignmentMode = .center
        hintLabel.preferredMaxLayoutWidth = overlayScene.size.width
        hintLabel.numberOfLines = 2
        hintLabel.lineBreakMode = .byWordWrapping

        // Configure the label background
        let labelBackground = SKShapeNode()

        // Give the background a slightly larger bounding rectangle in order to give the text a margin.
        let labelBackgroundSizeRect = hintLabel.frame.insetBy(dx: -10, dy: -10)
        labelBackground.path = CGPath(roundedRect: labelBackgroundSizeRect, cornerWidth: 5, cornerHeight: 5, transform: nil)
        labelBackground.position = CGPoint(x: sceneView.frame.midX, y: sceneView.frame.midY)
        labelBackground.strokeColor = UIColor.clear
        labelBackground.fillColor = UIColor.init(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.96)
        labelBackground.addChild(hintLabel)

        // Add the overlay and its contents to the scene.
        overlayScene.addChild(labelBackground)
        overlayScene.alpha = 0

        return overlayScene
    }
                </code></pre>

                <h3 id="displaying-overlay">Displaying the Overlay</h3>
                <p>Animating hints makes your app look more polished, and it makes displaying hints less jarring to the
                    user. This function fades in a SKNode, displays it for <code>displayDuration</code> seconds. This
                    function can be reused with any SKNode, not just an overlay.</p>

                <pre><code>
   func fadeNodeInAndOut(node: SKNode, initialDelay: Double, fadeInDuration: Double, displayDuration: Double, fadeOutDuration: Double) {
        // Fade in the label
        node.run(SKAction.sequence([
            .wait(forDuration: initialDelay),
            .fadeIn(withDuration: fadeInDuration)]))

        // Wait and fade out the label
        node.run(SKAction.sequence([
            .wait(forDuration: displayDuration),
            .fadeOut(withDuration: fadeOutDuration),
            .removeFromParent()]))
    }
                </code></pre>

                <a href="#">Back to top</a>
            </section>

            <section>
                <h2 id="location-based-ar">Location-Based AR</h2>
                <div class="row">
                    <div class="column">
                        <p>VT AR Tour pulls lat/long coordinates from an API and translates them into a local coordinate
                            system in order to render objects at their "real" positions in the virtual coordinate
                            system. This processing is very tricky, but if done correctly, objects can be rendered in
                            their real-world locations with a surprising level of accuracy!</p>
                    </div>
                    <div class="column" align="center">
                        <div>
                            <img src="../../images/ar-map.jpeg" width="45%"/>
                            <img src="../../images/vt-ar-tour.gif" width="45%"/>
                        </div>
                    </div>
                </div>

                <h3 id="getting-user-location">Getting the User's Location</h3>
                <p>A location-based AR App needs the highest degree of accuracy in order to correctly map real-world
                    coordinates to virtual ones. First get permission from the user, then configure the
                    CoreLocationManager to use the best accuracy possible.</p>
                <p>Make sure you have a strong reference to CLLocationManager, then get permission and configure the
                    location manger after the view has loaded.</p>
                <pre><code>
// A strong reference to CLLocationManager is required by the CoreLocation API
var locationManager = CLLocationManager()

override func viewDidLoad() {
    ...
    // User must enable location services to use this app
    if !CLLocationManager.locationServicesEnabled() {
        showAlertMessage(title: "Location Services Disabled", message: "You must enable location services to use this app")
        return
    }

    // Get the user's location
    locationManager.requestWhenInUseAuthorization()
    getLocation()
    ...
}

// Gets the user's location and reports all device movement
func getLocation() {
    // The user has not authorized location monitoring
    if (CLLocationManager.authorizationStatus() == .denied) {
        showAlertMessage(title: "App Not Authorized", message: "Unable to determine your location: please allow VT AR Tour to use your location.")

        // Try to get location authorization again
        locationManager.requestWhenInUseAuthorization()
    }

    locationManager.delegate = self

    // Report ALL device movement
    locationManager.distanceFilter = kCLDistanceFilterNone

    // Get the highest possible degree of accuracy
    locationManager.desiredAccuracy = kCLLocationAccuracyBest

    locationManager.startUpdatingLocation()
    locationManager.startUpdatingHeading()
}
                </code></pre>

                <h3 id="setting-up-coord-sys">Setting up Your Coordinate System</h3>
                <p>When an ARSession is launched, the AR coordinate system is based on the angle of the camera upon
                    launch by default. Luckily, ARKit can base the coordinate system on gravity and the compass heading
                    for a more real-world-like coordinate system.</p>
                <p>When you create your <code>ARWorldTrackingConfiguration</code>, be sure to correctly set the world
                    alignment.</p>
                <pre><code>
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    let configuration = ARWorldTrackingConfiguration()

    // Defines the ARSession's coordinate system based on gravity and the compass heading in the device. Note: THIS IS CRITICALLY IMPORTANT for location-based AR applications
    configuration.worldAlignment = .gravityAndHeading
    ...
    // Run the view's session
    sceneView.session.run(configuration)
}
                </code></pre>

                <h3 id="handling-location-updates">Handling Location Updates</h3>
                <p>As the user moves around, the LocationManager will notify your application with location updates. You
                    should update the location of each object in the scene every time this method is called. Here, those
                    updates are handled in <code>processBuilding()</code>.</p>
                <pre><code>
// New location data is available
func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    //  Must wait until at least one heading update comes through. If we proceed before this, our coordinate system won't be set up correctly
    guard (manager.heading?.magneticHeading) != nil else { return }

    // Don't process any further without the user's current location
    guard let currentLocation: CLLocation = locations.last else { return }

    // Fetch the VT Buildings JSON if necessary
    if jsonInDocumentDirectory == nil {
        jsonInDocumentDirectory = getVTBuildingsJSON()
    }

    if let jsonDataFromApi = jsonInDocumentDirectory {
        // Getting the JSON was successful
        do {
            let jsonArray = try JSONSerialization.jsonObject(with: jsonDataFromApi, options: .mutableContainers) as! NSArray

            for building in jsonArray {
                // Update the location and appearance of each buildingNode as necessary
                processBuilding(building, currentLocation)
            }
        } catch let error as NSError {
            showAlertMessage(title: "Error in JSON serialization", message: error.localizedDescription)
        }
    }
}
                </code></pre>

                <hr/>
                <h2 id="processing-buildings"">Processing Buildings</h2>
                <p>We create and render building nodes the first time we receive a location update. Afterwards, we
                    update the position and appearance of the building nodes with each location update.</p>
                <p>The rest of this section will focus on each step of processing, updating, and rendering
                    buildings.</p>
                <br/>
                <h3 id="computing-distance">Processing Buildings - Computing the Distance Between Coordinates</h3>
                <p>First, we determine if the building is close enough to the user to bother processing. If the building
                    is more than a quarter mile from the user, we don't waste CPU cycles updating nodes that are too far
                    for the user to see.</p>
                <img src="images/compute-distance.png" width="800"/>
                <p>The <code>distanceBetweenPointsInMiles()</code> function uses the <a
                        href="https://en.wikipedia.org/wiki/Haversine_formula" target="_blank">Haversine Formula</a> to
                    calculate the distance between two latitude/longitude points. Here, the points are the user's
                    location and each building's location.</p>
                <pre><code>
// MARK: - Degrees <--> Radians conversion functions

func degreesToRadians(_ degrees: Double) -> Double { return degrees * .pi / 180.0 }
func radiansToDegrees(_ radians: Double) -> Double { return radians * 180.0 / .pi }

// ----------------------------------------------
// MARK: - Position math (lat/long; matrix, etc)
// ----------------------------------------------

// MARK: Haversine formula
// Calculates the distance between two lat/long coordinates in miles.
// Modified from https://gist.github.com/Jamonek/16ecda78cebcd0da5862
func distanceBetweenPointsInMiles(lat1: Double, long1: Double, lat2: Double, long2: Double) -> Double {
    let radius: Double = 3959.0 // Average radius of the Earth in miles
    let deltaP = degreesToRadians(lat2) - degreesToRadians(lat1)
    let deltaL = degreesToRadians(long2) - degreesToRadians(long1)
    let a = sin(deltaP/2) * sin(deltaP/2) + cos(degreesToRadians(lat1)) * cos(degreesToRadians(lat2)) * sin(deltaL/2) * sin(deltaL/2)
    let c = 2 * atan2(sqrt(a), sqrt(1-a))
    let d = radius * c
    return d
}
                </code></pre>

                <h3 id="creating-label-nodes">Processing Buildings - Creating Building Label Nodes</h3>
                <p>Once we've computed a building's distance from the user, we create a SCNNode containing the
                    building's name. Later, we will add this node to the scene.</p>
                <div class="row">
                    <div class="column">
                        <img src="images/create-building-label-node-highlight.png" width="150%"/>
                    </div>
                    <div class="column" align="right">
                        <div>
                            <img src="images/building-label-node.jpeg" width="50%"/>
                        </div>
                    </div>
                </div>
                <p><code>createBuildingLabelNode()</code> creates a SCNNode that displays the building's name. This
                    takes a few steps:</p>
                <ol>
                    <li style="color: rgb(238, 64, 38)">Call <code>getARCoordinateOfBuilding()</code>, which translates
                        the building's
                        real-world coordinates to its corresponding AR coordinates.
                    </li>
                    <li style="color:rgb(0, 63, 245)">Get the (x, y, z) coordinates from the matrix's 3rd column (column
                        3 represents the node's position in 3D space) and wrap the coordinates into a SCNVector3.
                        SCNNode expects a SCNVector3 type in order to set its position.
                    </li>
                    <li style="color: rgb(111, 243, 74)">Set the node's properties.</li>
                </ol>
                <p>Step 1 is nontrivial, so it will be discussed in detail below. The numerical labels that
                    follow correspond the the numbers above. </p>
                <img src="images/create-building-label-node.png" width="800"/>
                <h3 style="color: rgb(238, 64, 38)">1. getARCoordinateOfBuilding()</h3>
                <p><b>Check-in</b>: At this point in computation, the application knows the user's lat/long the
                    building's lat/long, and the distance of the building from the user.</p>
                <p>We now compute the bearing between the building and the user in order to correctly position the
                    building in the AR coordinate system. Once obtained, we use the bearing to rotate the matrix around
                    the Y-axis (i.e. the ground) to place the building node in its position relative to the user's
                    camera. </p>
                <p>At this point, since things are beginning to get fairly complicated, we abstracted our matrix
                    operations into their own class, <code>MatrixHelper</code>, in order to shorten our functions. You
                    can view the MatrixHelper implementation <a
                            href="https://github.com/inorganik/MatrixHelper/blob/master/MatrixHelper.swift"
                            target="_blank">here</a>. </p>
                <p>The code that follows contains everything required to implement
                    <code>getARCoordinateOfBuilding()</code>. </p>
                <pre><code>
// Converts a CLLocation object to a matrix_float4x4 with the 3rd column representing the location in SCNKit coordinates
func getARCoordinateOfBuilding(userLocation: CLLocation, buildingLocation: CLLocation, distanceFromUserInMiles: Double) -> matrix_float4x4 {
    let bearing = getBearingBetweenPoints(point1: userLocation, point2: buildingLocation)
    let originTransform = matrix_identity_float4x4

    // Create a transform with a translation of distance meters away
    let milesPerMeter = 1609.344
    let distanceInMeters = distanceFromUserInMiles * milesPerMeter

    // Matrix that will hold the position of the building in AR coordinates
    var translationMatrix = matrix_identity_float4x4
    translationMatrix.columns.3.z = -1 * Float(distanceInMeters)

    // Rotate the position matrix
    let rotationMatrix = MatrixHelper.rotateMatrixAroundY(degrees: Float(bearing * -1), matrix: translationMatrix)

    // Multiply the rotation by the translation
    let transformMatrix = simd_mul(rotationMatrix, translationMatrix)

    // Multiply the origin by the translation to get the coordinates
    return simd_mul(originTransform, transformMatrix)
}

// Adapted from https://stackoverflow.com/questions/26998029/calculating-bearing-between-two-cllocation-points-in-swift
func getBearingBetweenPoints(point1 : CLLocation, point2 : CLLocation) -> Double {
    let lat1 = degreesToRadians(point1.coordinate.latitude)
    let lon1 = degreesToRadians(point1.coordinate.longitude)

    let lat2 = degreesToRadians(point2.coordinate.latitude)
    let lon2 = degreesToRadians(point2.coordinate.longitude)

    let dLon = lon2 - lon1

    let y = sin(dLon) * cos(lat2)
    let x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon)
    let radiansBearing = atan2(y, x)

    return radiansToDegrees(radiansBearing)
}
                </code></pre>

                <p>Steps 2 and 3 are self-explanatory and can be tailored to your own application as you wish.</p>
                <p>Finally, after all that math, the building label node has been created! Later, we will discuss adding
                    the node to the scene. </p>

                <hr/>
                <h3 id="creating-building-detail-nodes">Processing Buildings - Creating Building Detail Nodes</h3>
                <div class="row">
                    <div class="column">
                        <p>When the user is close to a building, we render a SCNNode that contains a
                            BuildingDetailsView. The BuildingDetailsNode is a SCNNode that contains a
                            BuildingDetailsView. This view is exactly
                            the same as the one that is shown to the user when the user taps on a building name to view
                            the
                            building details.</p>
                        <img src="images/process-building-details-node.png" width="150%"/>
                    </div>
                    <div class="column" align="right">
                        <div>
                            <img src="images/building-detail-node.jpeg" width="50%"/>
                        </div>
                    </div>
                </div>
                <br/>
                <p>Creating the populated BuildingDetailsSCNNode takes a few steps.</p>
                <img src="images/building-details-scn-node-step-1.png" width="80%"/>
                <h3>createBuildingDetailsViewControllerFromDict()</h3>
                <p>First, we create the BuildingDetails xib and the BuildingDetailsViewController. The BuildingDetails
                    view is described by a xib file in order to be reusable both in BuildingDetails nodes and the
                    BuildingDetailsView.</p>

                <div class="row">
                    <div class="column">
                        <img src="images/building-details-xib.png" width=100%/>
                    </div>
                    <div class="column">
                        <pre><code>
//
//  BuildingDetailsViewController.swift
//  VT AR Tour
//
//  Created by Patrick Gatewood on 11/21/17.
//  Copyright © 2017 Patrick Gatewood. All rights reserved.
//

import UIKit

protocol BuildingDetailsDelegate {
    func closeBuildingDetailsView(viewController: UIViewController)
}

class BuildingDetailsViewController: UIViewController {

    @IBOutlet var buildingNameLabel: UILabel!
    @IBOutlet var buildingImageview: UIImageView!
    @IBOutlet var scrollView: UIScrollView!
    @IBOutlet var buildingDescriptionLabel: UILabel!
    @IBOutlet var closeButton: UIButton!

    var delegate: BuildingDetailsDelegate?

    // Closes the BuildingDetailsView
    @IBAction func close(_ sender: UIButton) {
        if let buildingDetailsDelegate = delegate {
            buildingDetailsDelegate.closeBuildingDetailsView(viewController: self)
        }
    }

    // Give the view rounded corners
    override func viewDidLoad() {
        view.layer.cornerRadius = 20;
        view.layer.masksToBounds = true;
    }
}
                        </code></pre>
                    </div>
                </div>
                <p>It is worth noting here that the BuildingDetailsViewController defines its own protocol. This allows
                    its delegate to handle removing the ViewController from its parent, as that functionality is not
                    supported without delegation. The implementation in <code>ARViewController.swift</code> simply
                    animates out the ViewController's view and removes the ViewController from itself on completion.</p>
                <p>Once we've created the ViewController, we simply populate its view with data from a Building
                    dictionary. This gives us the full implementation of
                    createBuildingDetailsViewControllerFromDict().</p>
                <pre><code>
// Create a BuildingDetailsController and populate it asynchronously with data from the API
func createBuildingDetailsViewControllerFromDict(buildingDict: NSMutableDictionary?) -> BuildingDetailsViewController {
    // Create a new ViewController and pass it the selected building's data
    let buildingDetailViewController = BuildingDetailsViewController.init(nibName: "BuildingDetails", bundle: nil)
    buildingDetailViewController.delegate = self

    // NOTE: ViewController.view must be referenced at least once before referencing ANY IBOutlets in the ViewController. Referencing the `view` property implicity calls loadView(), which should never be called directly by the programmer.
    let _: UIView! = buildingDetailViewController.view

    // Display the building name
    buildingDetailViewController.buildingNameLabel.text = buildingDict?.value(forKey: "name") as? String

    // Get the building's image asynchronously and display it once available
    if let imageAddress = buildingDict?.value(forKey: "imageUrl") as? String,
        let buildingImageUrl = URL(string: imageAddress) {
            downloadAndDisplayImageAsync(url: buildingImageUrl, imageView: buildingDetailViewController.buildingImageview)
    }

    // Get the building's description asynchronously and display it once available
    if let descriptionAddress = buildingDict?.value(forKey: "descriptionUrl") as? String,
        let buildingDescriptionUrl = URL(string: descriptionAddress) {
            downloadAndDisplayLabelTextAsync(url: buildingDescriptionUrl, label: buildingDetailViewController.buildingDescriptionLabel)
    }

    return buildingDetailViewController
}
                </code></pre>
                <p>Note that downloading and displaying data from the API is done asynchronously. This will be discussed
                    later.</p>

                <h4>Building Detail Nodes - What's Left?</h4>
                <img src="images/populated-building-details-whats-left.png" width="80%"/>
                <p>The rest of this function is mostly configuration specific to this implementation. The most important
                    line is highlighted. Here, we set the SCNPlane's first material to the
                    BuildingDetailViewController's view. This whole configuration effectively renders a 2-dimensional
                    View in our 3D ARSCNView.</p>
                <hr/>
                <h3 id="adding-nodes-to-scene">Processing Buildings - Adding Nodes to the Scene</h3>
                <p>The two long sections above described creating the different types of nodes to be rendered in the
                    scene. This section will discuss adding the nodes to the scene and the logic used to determine which
                    node to display.</p>
                <img src="images/process-building-end.png" width="80%"/>
                <p>Finally, we're ready to add nodes to the scene. First, we check if the nodes are already in the
                    scene. If not, we add them. This handles initially adding nodes to the scene on launch. In addition,
                    it allows the app to add new nodes for buildings that were once too far away. So, if the user starts
                    walking across campus, the app will dynamically render new buildings as they come within range.</p>
                <img src="images/process-building-end-2.png" width="80%"/>
                <p>These checks determine whether to display a Building Label node vs. a Building Details node. If the
                    user is within range, the building label node is rendered. Otherwise, the label is rendered.</p>
                <p>With that, processing buildings is complete! In order for the nodes to maintain a high level of
                    location accuracy, this is done with every location update. Further optimizations are always
                    possible, however ruling out far-away buildings is enough to make the app run smoothly.git s</p>

                <a href="#">Back to top</a>
            </section>

            <section>
                <h2 id="async-data-download">Asynchronous Data Downloading</h2>
                <p>Earlier, when creating a building details view, we downloaded and displayed building images and their
                    descriptions asynchronously in order to not hang the main thread. Otherwise, the application would
                    completely freeze while waiting for a potentially large image to download!</p>
                <p>To prevent this, we use an <a
                        href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID546"
                        target="_blank">escaped closure</a>. This technique allows a closure to be passed into a
                    function as a parameter, but not executed until the function completes. We use this strategy to show
                    a loading indicator in the UI, download the contents of a url, and populate the UI on completion.
                </p>
                <h3 id="showing-loading-indicator">Showing the Loading Indicator</h3>
                <p>This function can show a loading indicator in the center of any subclass of UIView.</p>
                <pre><code>
// Create loading indicator and add it to the passed in view
func createAndShowLoadingIndicator(addToView: UIView) -> UIActivityIndicatorView {
    let loadingIndicator = UIActivityIndicatorView()

    // Add the loading indicator at the center of the view and begin the loading animation
    loadingIndicator.center = CGPoint(x: addToView.frame.size.width  / 2,
                                      y: addToView.frame.size.height / 2);
    addToView.addSubview(loadingIndicator)
    loadingIndicator.startAnimating()

    return loadingIndicator
}
                </code></pre>
                <h3 id="download-and-display-data">Downloading and Displaying Data</h3>
                <p>By abstracting out the completion handler into an escaped closure, this function can be reused
                    anywhere that requires an API call. Again, this function simply downloads data from a URL and
                    executes the <code>completion</code> closure once the data has been downloaded.</p>
                <pre><code>
// Downloads data on a background thread and executes the passed-in closure on completion
func getDataFromUrlAsync(url: URL, completion: @escaping (Data?, URLResponse?, Error?) -> ()) {
    URLSession.shared.dataTask(with: url) { data, response, error in
        completion(data, response, error)
        }.resume()
}
                </code></pre>
                <p>We reuse the above function for both downloading long strings and large images.</p>
                <pre><code>
// Download a String on a background thread and display it in the passed in UILabel once completed
func downloadAndDisplayLabelTextAsync(url: URL, label: UILabel) {
    var text: String?

    // Download the text and display it on completion
    getDataFromUrlAsync(url: url) { (data, response, error) in
        if error != nil {
            // Download failed
            text = "No data found"
        } else if let data = data {
            text = String(data: data, encoding: .utf8)
        }

        // Display the label
        DispatchQueue.main.async {
            label.text = text
        }
    }
}

// Download an image on a background thread and display it in the passed in UIImageView once completed
func downloadAndDisplayImageAsync(url: URL, imageView: UIImageView) {
    var image: UIImage?
    let loadingIndicator = createAndShowLoadingIndicator(addToView: imageView)

    // Download the image and display it on completion
    getDataFromUrlAsync(url: url) { (data, response, error) in
        if error != nil {
            // Download failed
            image = UIImage(named: "no-image")
        } else if let data = data {
            image = UIImage(data: data)
        }

        // Display the image
        DispatchQueue.main.async {
            loadingIndicator.stopAnimating()
            loadingIndicator.removeFromSuperview()
            imageView.image = image
        }
    }
}
                </code></pre>
                <p>With that, data is downloaded asynchronously and doesn't slow down the GUI thread!</p>

                <a href="#">Back to top</a>
            </section>

            <section>
                <h2 id="leaving-ar">Leaving an AR View</h2>
                <div class="row">
                    <div class="column">
                        <p>If your application is more than just one ARSCNView, it may make sense to allow your user to
                            escape the ARSCNView and go back to the previous view. There are <b>two</b> easy ways to do
                            this: a back button and a UINavigationController.</p>
                    </div>
                    <div class="column" align="center">
                        <img src="images/exit-ar.jpeg" width="50%"/>
                    </div>
                </div>

                <h3 id="back-button">Option 1: Back Button&nbsp;&nbsp;<i class="fa fa-mail-reply fa-2x"></i></h3>
                <p>A back button is familiar to all users. In order to prevent disrupting your user's experience, you'll
                    only want to show it for a few seconds.</p>
                <h4>Button Setup</h4>
                <p>Call <code>setupBackButton()</code> in <code>viewWillAppear()</code> to create a back button and
                    display it for a few seconds.</p>
                <pre><code>
    // Global reference to backButton
    var backButton: UIImageView = UIImageView(image: UIImage(named: "back-icon"))

    // Creates a back button and adds it to the scene
    func setupBackButton() {
        // Position the button right under the status bar
        backButton.frame = CGRect(x: 25, y: 40, width: 35, height: 35)
        view.addSubview(backButton)

        // Fade out the back button after a few seconds.
        UIView.animateKeyframes(withDuration: 1.0, delay: 6.0, options: .allowUserInteraction, animations: {
            self.backButton.alpha = 0
        }, completion: { (finished: Bool) in
            self.backButton.isHidden = true
        })
    }
                </code></pre>

                <h4>Detecting a Back Button Press</h4>
                <p>You will likely be using hit tests (as learned in the <a href="../models-and-physics/tutorial.html">models
                    and physics</a> tutorial to determine if the user tapped an object in the scene. Rather than adding
                    a TapGestureRecognizer to our back button and overcomplicating the way our application handles tap
                    gestures, we can add our back button logic to our ARSCNView's tap gesture handling method. </p>
                <p>Add this code to your tap handling method to return to the previous ViewController when the user taps
                    the back button.</p>
                <pre><code>
    @IBAction func userTappedScreen(_ sender: UITapGestureRecognizer) {
        let screenTapPoint: CGPoint = sender.location(in: self.view)

        // User tapped the back button
        if backButton.frame.contains(screenTapPoint) && !backButton.isHidden {
            navigationController?.popViewController(animated: true)
            return
        }

        ...

        // If the back button is hidden and your hit test has no results... show the back button for a few seconds
        {
            let animationTime = 1.0
            let animationDelay = 3.0

            // Display back button for a few seconds
            UIView.animate(withDuration: animationTime, delay: 0, animations: {
                    self.backButton.alpha = 1.0
            }, completion:{ (finished: Bool) in
                self.backButton.isHidden = false
            })

            // Fade back out
            UIView.animate(withDuration: animationTime, delay: animationDelay, options: UIViewAnimationOptions.allowUserInteraction, animations: {
                self.backButton.alpha = 0
            }, completion: { (finished: Bool) in
                self.backButton.isHidden = true
            })
        }
     }
                </code></pre>

                <h3 id="ui-navigation-controller">Option 2: UINavigationController</h3>
                <p>If your ARSCNView is the child of a UINavigationController, you can hide the bar and use
                    UINavigationController's built-in "edge-pan to go back" gesture.</p>
                <p>In your <code>viewDidLoad()</code> method, set the <code>interactivePopGestureRecognizer</code>
                    Delegate to your ARViewController. This lets your ARSCNView pass edge-pad gestures to the view's
                    NavigationController.</p>

                <pre><code>
override func viewDidLoad() {
    ...
  // Required for "swipe right to go back" gesture with a hidden navigation bar
    navigationController?.interactivePopGestureRecognizer?.delegate = self
    ...
}
        </code></pre>

                <a href="#">Back to top</a>
            </section>

        </div>
    </div>

</div>


</body>
</html>